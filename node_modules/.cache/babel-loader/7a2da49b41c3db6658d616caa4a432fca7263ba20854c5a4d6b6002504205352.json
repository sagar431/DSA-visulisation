{"ast":null,"code":"export const quickSort = originalArray => {\n  // Create a copy of the array to avoid modifying the original\n  const array = [...originalArray];\n  const steps = [];\n\n  // Initial step showing the unsorted array\n  steps.push({\n    array: [...array],\n    description: \"Starting with the unsorted array\",\n    codeLineNumber: 1\n  });\n\n  // Call the recursive quicksort function\n  quickSortHelper(array, 0, array.length - 1, steps);\n\n  // Final step showing the sorted array\n  steps.push({\n    array: [...array],\n    sortedIndices: Array.from({\n      length: array.length\n    }, (_, i) => i),\n    description: \"Array is now sorted\",\n    codeLineNumber: 3\n  });\n  return {\n    sortedArray: array,\n    steps\n  };\n};\nconst quickSortHelper = (array, low, high, steps) => {\n  if (low < high) {\n    // Add step to show the current subarray we're working on\n    steps.push({\n      array: [...array],\n      description: `Working on subarray from index ${low} to ${high}`,\n      codeLineNumber: 6\n    });\n\n    // Partition the array and get the pivot index\n    const pivotIndex = partition(array, low, high, steps);\n\n    // Add step to show the partition is complete\n    steps.push({\n      array: [...array],\n      pivotIndex,\n      description: `Partition complete. Pivot (${array[pivotIndex]}) is now at its correct position (index ${pivotIndex})`,\n      codeLineNumber: 7\n    });\n\n    // Recursively sort the left part\n    quickSortHelper(array, low, pivotIndex - 1, steps);\n\n    // Recursively sort the right part\n    quickSortHelper(array, pivotIndex + 1, high, steps);\n  }\n};\nconst partition = (array, low, high, steps) => {\n  // Choose the rightmost element as pivot\n  const pivot = array[high];\n\n  // Add step to show pivot selection\n  steps.push({\n    array: [...array],\n    pivotIndex: high,\n    description: `Selected pivot: ${pivot} at index ${high}`,\n    codeLineNumber: 13\n  });\n\n  // Index of smaller element\n  let i = low - 1;\n\n  // Add step to show initialization of i\n  steps.push({\n    array: [...array],\n    pivotIndex: high,\n    leftIndex: i,\n    description: `Initialize i = ${i} (index of smaller element)`,\n    codeLineNumber: 14\n  });\n\n  // Traverse through all elements\n  // compare each element with pivot\n  for (let j = low; j < high; j++) {\n    // Add step to show current comparison\n    steps.push({\n      array: [...array],\n      pivotIndex: high,\n      leftIndex: i,\n      rightIndex: j,\n      description: `Comparing element at index ${j} (${array[j]}) with pivot (${pivot})`,\n      codeLineNumber: 17\n    });\n\n    // If current element is smaller than the pivot\n    if (array[j] < pivot) {\n      // Increment index of smaller element\n      i++;\n\n      // Add step to show increment of i\n      steps.push({\n        array: [...array],\n        pivotIndex: high,\n        leftIndex: i,\n        rightIndex: j,\n        description: `Element ${array[j]} is less than pivot ${pivot}, incrementing i to ${i}`,\n        codeLineNumber: 19\n      });\n\n      // Swap elements\n      [array[i], array[j]] = [array[j], array[i]];\n\n      // Add step to show the swap\n      steps.push({\n        array: [...array],\n        pivotIndex: high,\n        leftIndex: i,\n        rightIndex: j,\n        swappedIndices: [i, j],\n        description: `Swapped elements at indices ${i} and ${j}: ${array[i]} and ${array[j]}`,\n        codeLineNumber: 20\n      });\n    }\n  }\n\n  // Swap the pivot element with the element at (i + 1)\n  [array[i + 1], array[high]] = [array[high], array[i + 1]];\n\n  // Add step to show the final pivot swap\n  steps.push({\n    array: [...array],\n    pivotIndex: i + 1,\n    swappedIndices: [i + 1, high],\n    description: `Placed pivot at its correct position by swapping elements at indices ${i + 1} and ${high}`,\n    codeLineNumber: 25\n  });\n\n  // Return the position where partition is done\n  return i + 1;\n};","map":{"version":3,"names":["quickSort","originalArray","array","steps","push","description","codeLineNumber","quickSortHelper","length","sortedIndices","Array","from","_","i","sortedArray","low","high","pivotIndex","partition","pivot","leftIndex","j","rightIndex","swappedIndices"],"sources":["/home/sagar/Desktop/DSA vislulisation/src/algorithms/quickSort.ts"],"sourcesContent":["export interface SortStep {\n  array: number[];\n  pivotIndex?: number;\n  leftIndex?: number;\n  rightIndex?: number;\n  swappedIndices?: [number, number];\n  sortedIndices?: number[];\n  description: string;\n  codeLineNumber: number;\n}\n\nexport interface QuickSortResult {\n  sortedArray: number[];\n  steps: SortStep[];\n}\n\nexport const quickSort = (\n  originalArray: number[]\n): QuickSortResult => {\n  // Create a copy of the array to avoid modifying the original\n  const array = [...originalArray];\n  const steps: SortStep[] = [];\n  \n  // Initial step showing the unsorted array\n  steps.push({\n    array: [...array],\n    description: \"Starting with the unsorted array\",\n    codeLineNumber: 1\n  });\n\n  // Call the recursive quicksort function\n  quickSortHelper(array, 0, array.length - 1, steps);\n  \n  // Final step showing the sorted array\n  steps.push({\n    array: [...array],\n    sortedIndices: Array.from({ length: array.length }, (_, i) => i),\n    description: \"Array is now sorted\",\n    codeLineNumber: 3\n  });\n\n  return {\n    sortedArray: array,\n    steps\n  };\n};\n\nconst quickSortHelper = (\n  array: number[],\n  low: number,\n  high: number,\n  steps: SortStep[]\n): void => {\n  if (low < high) {\n    // Add step to show the current subarray we're working on\n    steps.push({\n      array: [...array],\n      description: `Working on subarray from index ${low} to ${high}`,\n      codeLineNumber: 6\n    });\n\n    // Partition the array and get the pivot index\n    const pivotIndex = partition(array, low, high, steps);\n    \n    // Add step to show the partition is complete\n    steps.push({\n      array: [...array],\n      pivotIndex,\n      description: `Partition complete. Pivot (${array[pivotIndex]}) is now at its correct position (index ${pivotIndex})`,\n      codeLineNumber: 7\n    });\n\n    // Recursively sort the left part\n    quickSortHelper(array, low, pivotIndex - 1, steps);\n    \n    // Recursively sort the right part\n    quickSortHelper(array, pivotIndex + 1, high, steps);\n  }\n};\n\nconst partition = (\n  array: number[],\n  low: number,\n  high: number,\n  steps: SortStep[]\n): number => {\n  // Choose the rightmost element as pivot\n  const pivot = array[high];\n  \n  // Add step to show pivot selection\n  steps.push({\n    array: [...array],\n    pivotIndex: high,\n    description: `Selected pivot: ${pivot} at index ${high}`,\n    codeLineNumber: 13\n  });\n\n  // Index of smaller element\n  let i = low - 1;\n  \n  // Add step to show initialization of i\n  steps.push({\n    array: [...array],\n    pivotIndex: high,\n    leftIndex: i,\n    description: `Initialize i = ${i} (index of smaller element)`,\n    codeLineNumber: 14\n  });\n\n  // Traverse through all elements\n  // compare each element with pivot\n  for (let j = low; j < high; j++) {\n    // Add step to show current comparison\n    steps.push({\n      array: [...array],\n      pivotIndex: high,\n      leftIndex: i,\n      rightIndex: j,\n      description: `Comparing element at index ${j} (${array[j]}) with pivot (${pivot})`,\n      codeLineNumber: 17\n    });\n\n    // If current element is smaller than the pivot\n    if (array[j] < pivot) {\n      // Increment index of smaller element\n      i++;\n      \n      // Add step to show increment of i\n      steps.push({\n        array: [...array],\n        pivotIndex: high,\n        leftIndex: i,\n        rightIndex: j,\n        description: `Element ${array[j]} is less than pivot ${pivot}, incrementing i to ${i}`,\n        codeLineNumber: 19\n      });\n      \n      // Swap elements\n      [array[i], array[j]] = [array[j], array[i]];\n      \n      // Add step to show the swap\n      steps.push({\n        array: [...array],\n        pivotIndex: high,\n        leftIndex: i,\n        rightIndex: j,\n        swappedIndices: [i, j],\n        description: `Swapped elements at indices ${i} and ${j}: ${array[i]} and ${array[j]}`,\n        codeLineNumber: 20\n      });\n    }\n  }\n  \n  // Swap the pivot element with the element at (i + 1)\n  [array[i + 1], array[high]] = [array[high], array[i + 1]];\n  \n  // Add step to show the final pivot swap\n  steps.push({\n    array: [...array],\n    pivotIndex: i + 1,\n    swappedIndices: [i + 1, high],\n    description: `Placed pivot at its correct position by swapping elements at indices ${i + 1} and ${high}`,\n    codeLineNumber: 25\n  });\n  \n  // Return the position where partition is done\n  return i + 1;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}