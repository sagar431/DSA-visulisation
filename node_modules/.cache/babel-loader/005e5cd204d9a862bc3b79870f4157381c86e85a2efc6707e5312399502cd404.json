{"ast":null,"code":"export const bubbleSort = originalArray => {\n  const array = [...originalArray];\n  const steps = [];\n  let comparisons = 0;\n  let swaps = 0;\n  const sortedIndices = [];\n\n  // Add initial state\n  steps.push({\n    array: [...array],\n    sortedIndices: [...sortedIndices]\n  });\n  for (let i = 0; i < array.length; i++) {\n    let swapped = false;\n    for (let j = 0; j < array.length - i - 1; j++) {\n      // Add step to show comparison\n      steps.push({\n        array: [...array],\n        comparing: [j, j + 1],\n        sortedIndices: [...sortedIndices]\n      });\n      comparisons++;\n      if (array[j] > array[j + 1]) {\n        // Swap elements\n        [array[j], array[j + 1]] = [array[j + 1], array[j]];\n        swapped = true;\n        swaps++;\n\n        // Add step to show swap\n        steps.push({\n          array: [...array],\n          swappedIndices: [j, j + 1],\n          sortedIndices: [...sortedIndices]\n        });\n      }\n    }\n\n    // Mark the last unsorted element as sorted\n    sortedIndices.unshift(array.length - 1 - i);\n\n    // Add step to show updated sorted portion\n    steps.push({\n      array: [...array],\n      sortedIndices: [...sortedIndices]\n    });\n\n    // If no swaps were made in this pass, the array is already sorted\n    if (!swapped) {\n      // Mark all remaining elements as sorted\n      for (let k = 0; k < array.length; k++) {\n        if (!sortedIndices.includes(k)) {\n          sortedIndices.push(k);\n        }\n      }\n\n      // Add final state with all elements sorted\n      steps.push({\n        array: [...array],\n        sortedIndices: sortedIndices.sort((a, b) => a - b)\n      });\n      break;\n    }\n  }\n  return {\n    sortedArray: array,\n    steps,\n    comparisons,\n    swaps\n  };\n};","map":{"version":3,"names":["bubbleSort","originalArray","array","steps","comparisons","swaps","sortedIndices","push","i","length","swapped","j","comparing","swappedIndices","unshift","k","includes","sort","a","b","sortedArray"],"sources":["/home/sagar/Desktop/DSA vislulisation/src/algorithms/bubbleSort.ts"],"sourcesContent":["export interface BubbleSortStep {\n  array: number[];\n  comparing?: [number, number];\n  swappedIndices?: [number, number];\n  sortedIndices: number[];\n}\n\nexport interface BubbleSortResult {\n  sortedArray: number[];\n  steps: BubbleSortStep[];\n  comparisons: number;\n  swaps: number;\n}\n\nexport const bubbleSort = (originalArray: number[]): BubbleSortResult => {\n  const array = [...originalArray];\n  const steps: BubbleSortStep[] = [];\n  let comparisons = 0;\n  let swaps = 0;\n  const sortedIndices: number[] = [];\n\n  // Add initial state\n  steps.push({\n    array: [...array],\n    sortedIndices: [...sortedIndices]\n  });\n\n  for (let i = 0; i < array.length; i++) {\n    let swapped = false;\n    \n    for (let j = 0; j < array.length - i - 1; j++) {\n      // Add step to show comparison\n      steps.push({\n        array: [...array],\n        comparing: [j, j + 1],\n        sortedIndices: [...sortedIndices]\n      });\n      \n      comparisons++;\n      \n      if (array[j] > array[j + 1]) {\n        // Swap elements\n        [array[j], array[j + 1]] = [array[j + 1], array[j]];\n        swapped = true;\n        swaps++;\n        \n        // Add step to show swap\n        steps.push({\n          array: [...array],\n          swappedIndices: [j, j + 1],\n          sortedIndices: [...sortedIndices]\n        });\n      }\n    }\n    \n    // Mark the last unsorted element as sorted\n    sortedIndices.unshift(array.length - 1 - i);\n    \n    // Add step to show updated sorted portion\n    steps.push({\n      array: [...array],\n      sortedIndices: [...sortedIndices]\n    });\n    \n    // If no swaps were made in this pass, the array is already sorted\n    if (!swapped) {\n      // Mark all remaining elements as sorted\n      for (let k = 0; k < array.length; k++) {\n        if (!sortedIndices.includes(k)) {\n          sortedIndices.push(k);\n        }\n      }\n      \n      // Add final state with all elements sorted\n      steps.push({\n        array: [...array],\n        sortedIndices: sortedIndices.sort((a, b) => a - b)\n      });\n      \n      break;\n    }\n  }\n\n  return {\n    sortedArray: array,\n    steps,\n    comparisons,\n    swaps\n  };\n};\n"],"mappings":"AAcA,OAAO,MAAMA,UAAU,GAAIC,aAAuB,IAAuB;EACvE,MAAMC,KAAK,GAAG,CAAC,GAAGD,aAAa,CAAC;EAChC,MAAME,KAAuB,GAAG,EAAE;EAClC,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,KAAK,GAAG,CAAC;EACb,MAAMC,aAAuB,GAAG,EAAE;;EAElC;EACAH,KAAK,CAACI,IAAI,CAAC;IACTL,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;IACjBI,aAAa,EAAE,CAAC,GAAGA,aAAa;EAClC,CAAC,CAAC;EAEF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,KAAK,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAIE,OAAO,GAAG,KAAK;IAEnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,KAAK,CAACO,MAAM,GAAGD,CAAC,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;MAC7C;MACAR,KAAK,CAACI,IAAI,CAAC;QACTL,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;QACjBU,SAAS,EAAE,CAACD,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;QACrBL,aAAa,EAAE,CAAC,GAAGA,aAAa;MAClC,CAAC,CAAC;MAEFF,WAAW,EAAE;MAEb,IAAIF,KAAK,CAACS,CAAC,CAAC,GAAGT,KAAK,CAACS,CAAC,GAAG,CAAC,CAAC,EAAE;QAC3B;QACA,CAACT,KAAK,CAACS,CAAC,CAAC,EAAET,KAAK,CAACS,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAACT,KAAK,CAACS,CAAC,GAAG,CAAC,CAAC,EAAET,KAAK,CAACS,CAAC,CAAC,CAAC;QACnDD,OAAO,GAAG,IAAI;QACdL,KAAK,EAAE;;QAEP;QACAF,KAAK,CAACI,IAAI,CAAC;UACTL,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;UACjBW,cAAc,EAAE,CAACF,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;UAC1BL,aAAa,EAAE,CAAC,GAAGA,aAAa;QAClC,CAAC,CAAC;MACJ;IACF;;IAEA;IACAA,aAAa,CAACQ,OAAO,CAACZ,KAAK,CAACO,MAAM,GAAG,CAAC,GAAGD,CAAC,CAAC;;IAE3C;IACAL,KAAK,CAACI,IAAI,CAAC;MACTL,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;MACjBI,aAAa,EAAE,CAAC,GAAGA,aAAa;IAClC,CAAC,CAAC;;IAEF;IACA,IAAI,CAACI,OAAO,EAAE;MACZ;MACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,KAAK,CAACO,MAAM,EAAEM,CAAC,EAAE,EAAE;QACrC,IAAI,CAACT,aAAa,CAACU,QAAQ,CAACD,CAAC,CAAC,EAAE;UAC9BT,aAAa,CAACC,IAAI,CAACQ,CAAC,CAAC;QACvB;MACF;;MAEA;MACAZ,KAAK,CAACI,IAAI,CAAC;QACTL,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;QACjBI,aAAa,EAAEA,aAAa,CAACW,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC;MACnD,CAAC,CAAC;MAEF;IACF;EACF;EAEA,OAAO;IACLC,WAAW,EAAElB,KAAK;IAClBC,KAAK;IACLC,WAAW;IACXC;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}